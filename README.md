# a simple Frequency counter with an equivalent precision measurement

## project structure
- "doc": the information for each module (see .md)

- "rtl": the implementation of all modules (see .v)

- "sim": all testbenches of each module

***
## Principle

Neither the frequency measurement nor the period measurement are exact multiples of the clock cycle within the measurement time t. It will create an error of ±1 clock cycle. Consequently, neither of them perform well at both high and low frequencies. 

We set a standard clock(clk_stand), with a known frequency(fs) as a reference to determine the frequency(fx) of the measured clock(clk_test). 

![equivalent precision measurement.bmp](https://github.com/KaihaoYuHW/Verilog_a_simple_Frequency_counter/blob/main/doc/equivalent%20precision%20measurement.bmp)

I plan a complete cycle for gate_a with a duration of 1.5 seconds. The first 0.25 seconds is low for resetting various counters, the middle 1 second is high for calculating the number of clk cycles for clk_test and clk_stand. At last the final 0.25 seconds is low again. After total 1.5 seconds, calculate the frequency fx of clk_test. 

The measurement time TX is an integer multiple of the clk_test period, eliminating the error of ±1 clock cycle generated by clk_test. However, it will also introduce an error of ±1 clock cycle for clk_stand, as TX is not necessarily an integer multiple of the clk_stand period. This error can be reduced and measurement accuracy improved by increasing TX or raising the frequency fs of clk_stand. We set TX = 1s and fs = 100Mhz. 

## calculation

1. Calculate the number X of clock cycles for clk_test in period of TX . Set fX ist the frequency of clk_test. Tx = X / fX
2. Calculate the number Y of clock cycles for clk_stand in period of TX . Set fY ist the frequency of clk_stand. Tx = Y / fY
3. X / fX = Y / fY , fX = X * fs / Y

## implementation

In this architecture, I need 3 clock inputs. They are system clock cycle sys_clk(50Mhz), measured clock clk_test, standard clock clk_stand(100Mhz). I use PLL to generate clk_stand. 

**NOTICE: In ISE, if a built-in IP core is introduced, for example, a PLL generates 100Mhz (clk_stand) from a 50Mhz (sys_clk). This PLL reads the sys_clk on the FPGA into CLK_IN1, generating a clock output CLK_OUT1 with a frequency of 100Mhz (clk_stand). This input is buffered, so after passing through this PLL module, the sys_clk on the FPGA cannot be directly read again, otherwise it will cause an error: Xst: 2035.**

**SOLUTION: This PLL generates another 50Mhz clock as sys_clk for the subsequent modules.**
